package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"api/graph/models"
	"api/pkg/gollama"
	"context"
	"fmt"
	"log"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/v2/bson"
)

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context) (*models.Chat, error) {
	coll := r.Client.Database("alpaca").Collection("chats")
	doc := &models.Chat{
		ID:          primitive.NewObjectID(),
		Title:       "unamed chat",
		Model:       "NONE",
		Messages:    make([]*models.Message, 0),
		LastChanged: time.Now().UTC(),
	}

	if _, err := coll.InsertOne(ctx, doc); err != nil {
		return nil, err
	}

	return doc, nil
}

// Chat is the resolver for the chat field.
func (r *queryResolver) Chat(ctx context.Context, id primitive.ObjectID) (*models.Chat, error) {
	filter := bson.M{"_id": id}
	coll := r.Client.Database("alpaca").Collection("chats")
	chat := new(models.Chat)
	if err := coll.FindOne(ctx, filter).Decode(chat); err != nil {
		return nil, err
	}
	return chat, nil
}

// Chats is the resolver for the chats field.
func (r *queryResolver) Chats(ctx context.Context) ([]*models.Chat, error) {
	coll := r.Client.Database("alpaca").Collection("chats")

	cursor, err := coll.Find(ctx, bson.M{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	var chats []*models.Chat
	for cursor.Next(ctx) {
		var chat models.Chat
		if err := cursor.Decode(&chat); err != nil {
			return nil, err
		}
		chats = append(chats, &chat)
	}

	if err := cursor.Err(); err != nil {
		return nil, err
	}

	return chats, nil
}

// Send is the resolver for the send field.
func (r *subscriptionResolver) Send(ctx context.Context, id primitive.ObjectID, model string, content string) (<-chan *models.Response, error) {
	log.Println(content)
	responses := make(chan *models.Response)
	bgCtx, cancel := context.WithCancel(context.Background())

	go func() {
		defer func() {
			close(responses)
			cancel()
		}()
		handler := func(response *models.Response) error {
			log.Println(response.Message.Content)
			select {
			case responses <- response:
				return nil
			case <-bgCtx.Done():
				return fmt.Errorf("background context closed")
			}
		}

		filter := bson.M{"_id": id}
		coll := r.Client.Database("alpaca").Collection("chats")
		var chat models.Chat
		err := coll.FindOne(ctx, filter).Decode(&chat)
		chat.Model = model
		chat.Messages = append(chat.Messages, &models.Message{Role: "user", Content: content})
		chat.LastChanged = time.Now().UTC()
		coll.ReplaceOne(ctx, filter, chat)

		message, err := gollama.Send("http://localhost:11434", &chat, handler)
		if err != nil {
			log.Printf("Error in send: %v\n", err)
		}
		chat.Messages = append(chat.Messages, message)
		chat.LastChanged = time.Now().UTC()
		coll.ReplaceOne(ctx, filter, chat)
	}()

	return responses, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
